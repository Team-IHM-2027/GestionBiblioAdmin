// src/services/bookService.ts
import { collection, doc, addDoc, getDoc, updateDoc, deleteDoc, getDocs, query, where, arrayUnion } from 'firebase/firestore';
import { db } from '../config/firebase';
import type { Book, Comment } from '../types/book';

const booksCollectionRef = collection(db, 'BiblioBooks');

export const fetchBooksByDepartment = async (departmentName: string): Promise<Book[]> => {
	// Add a console log to see exactly what value we're querying with
	console.log(`[bookService] Querying Firestore for categorie: "${departmentName}"`);

	try {
		const q = query(booksCollectionRef, where('cathegorie', '==', departmentName));
		const querySnapshot = await getDocs(q);

		if (querySnapshot.empty) {
			console.warn(`[bookService] No documents found for categorie: "${departmentName}". Check your Firestore data and indexes.`);
		}

		const books = querySnapshot.docs.map(doc => ({
			id: doc.id,
			...doc.data()
		})) as Book[];

		// Add a log to see the results
		console.log(`[bookService] Found ${books.length} books.`, books);

		return books;
	} catch (error) {
		console.error(`[bookService] Error fetching books for department "${departmentName}":`, error);
		throw new Error('Failed to fetch books.');
	}
};

/**
 * Fetches a single book by its ID from Firestore.
 * @param bookId The ID of the book to fetch.
 * @returns A promise that resolves to the Book object or null if not found.
 */
export const fetchBookById = async (bookId: string): Promise<Book | null> => {
	try {

		const bookDocRef = doc(db, 'BiblioBooks', bookId);

		const docSnap = await getDoc(bookDocRef);

		if (docSnap.exists()) {
			return { id: docSnap.id, ...docSnap.data() } as Book;
		} else {
			console.warn(`No book found with ID: ${bookId}`);
			return null;
		}
	} catch (error) {
		console.error("Error fetching book by ID:", error);
		throw new Error('Failed to fetch book details.');
	}
};

/**
 * Updates a book's data in Firestore.
 * @param bookId The ID of the book to update.
 * @param data The partial data to update.
 */
export const updateBook = async (bookId: string, data: Partial<Book>): Promise<void> => {

	const bookDocRef = doc(db, 'BiblioBooks', bookId);

	await updateDoc(bookDocRef, data);
};

/**
 * Deletes a book from Firestore.
 * @param bookId The ID of the book to delete.
 */
export const deleteBook = async (bookId: string): Promise<void> => {

	const bookDocRef = doc(db, 'BiblioBooks', bookId);

	await deleteDoc(bookDocRef);
};

/**
 * Adds a comment to a book's comment array in Firestore.
 * @param bookId The ID of the book to add the comment to.
 * @param comment The comment object to add.
 */
export const addCommentToBook = async (bookId: string, comment: Comment): Promise<void> => {
	try {

		const bookDocRef = doc(db, 'BiblioBooks', bookId);

		// arrayUnion is the perfect tool for this: it adds a new element to an array
		// without reading and rewriting the entire array.
		await updateDoc(bookDocRef, {
			commentaire: arrayUnion(comment)
		});
	} catch (error) {
		console.error("Error adding comment in service:", error);
		throw new Error("Failed to post comment.");
	}
};

/**
 * Checks if a book is currently part of an active loan or reservation.
 * @param bookName The name of the book to check.
 * @returns An object indicating if the book is in use and the reason.
 */
export const isBookInUse = async (bookName: string): Promise<{ inUse: boolean; reason: string }> => {
	const usersCollectionRef = collection(db, 'BiblioUser');
	const usersSnapshot = await getDocs(usersCollectionRef);

	for (const userDoc of usersSnapshot.docs) {
		const userData = userDoc.data();
		const states = ['etat1', 'etat2', 'etat3'];
		const tabs = ['tabEtat1', 'tabEtat2', 'tabEtat3'];

		for (let i = 0; i < states.length; i++) {
			if ((userData[states[i]] === 'reserv' || userData[states[i]] === 'emprunt') && userData[tabs[i]]?.[0] === bookName) {
				return { inUse: true, reason: `Book is currently ${userData[states[i]]} by user ${userData.name}.` };
			}
		}
	}

	return { inUse: false, reason: '' };
};


/**
 * Adds a new book to the "BiblioBooks" collection in Firestore.

 * @param bookData - The data for the new book, excluding the ID.
 */
export const addBook = async (bookData: Omit<Book, 'id'>): Promise<void> => {
	try {

		const docRef = await addDoc(collection(db, 'BiblioBooks'), bookData);

		// The document ID is automatically generated by Firestore.
		console.log("Book added with ID: ", docRef.id);
	} catch (error) {
		console.error("Error adding book in service:", error);
		throw new Error("Failed to add the new book.");
	}
};
